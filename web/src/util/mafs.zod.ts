// Generated by ts-to-zod
import React from "react";
import { z } from "zod";

export const vector2Schema = z.tuple([z.number(), z.number()]);

export const matrixSchema = z.tuple([
  z.number(),
  z.number(),
  z.number(),
  z.number(),
  z.number(),
  z.number(),
  z.number(),
  z.number(),
  z.number(),
]);

export const intervalSchema = z.tuple([z.number(), z.number()]);

const paneContextShapeSchema = z.object({
  xPanes: z.array(intervalSchema),
  yPanes: z.array(intervalSchema),
  xPaneRange: intervalSchema,
  yPaneRange: intervalSchema,
});

const transformContextShapeSchema = z.object({
  userTransform: matrixSchema,
  viewTransform: matrixSchema,
});

export const labelMakerSchema = z
  .function()
  .args(z.number())
  .returns(z.union([z.number(), z.string()]));

export const axisOptionsSchema = z.object({
  axis: z.boolean(),
  lines: z.union([z.number(), z.literal(false)]),
  subdivisions: z.union([z.number(), z.literal(false)]),
  labels: z.union([z.literal(false), labelMakerSchema]),
});

export const cartesianCoordinatesPropsSchema = z.object({
  type: z.literal("cartesianCoordinates"),
  xAxis: z.union([axisOptionsSchema.partial(), z.literal(false)]).optional(),
  yAxis: z.union([axisOptionsSchema.partial(), z.literal(false)]).optional(),
  subdivisions: z.union([z.number(), z.literal(false)]).optional(),
});

export const filledSchema = z.object({
  color: z.string().optional(),
  weight: z.number().optional(),
  fillOpacity: z.number().optional(),
  strokeOpacity: z.number().optional(),
  strokeStyle: z.union([z.literal("solid"), z.literal("dashed")]).optional(),
});

export const strokedSchema = z.object({
  color: z.string().optional(),
  opacity: z.number().optional(),
  weight: z.number().optional(),
  style: z.union([z.literal("solid"), z.literal("dashed")]).optional(),
});

export const parametricPropsSchema = strokedSchema.extend({
  type: z.literal("parametric"),
  xy: z.string(),
  t: vector2Schema,
  minSamplingDepth: z.number().optional(),
  maxSamplingDepth: z.number().optional(),
});

export const vectorFieldPropsSchema = z.object({
  type: z.literal("vectorField"),
  xy: z.string(),
  xyOpacity: z.string().optional(),
  step: z.number(),
  opacityStep: z.number().optional(),
  color: z.string().optional(),
});

export const ofXPropsSchema = parametricPropsSchema.extend({
  type: z.literal("ofX"),
  y: z.string(),
}).omit({ xy: true, t: true });

export const ofYPropsSchema = parametricPropsSchema.extend({
  type: z.literal("ofY"),
  x: z.string()
}).omit({ xy: true, t: true });

export const throughPointsPropsSchema = strokedSchema.extend({
  type: z.literal("throughPoints"),
  point1: vector2Schema,
  point2: vector2Schema,
});

export const pointAnglePropsSchema = strokedSchema.extend({
  type: z.literal("pointAngle"),
  point: vector2Schema,
  angle: z.number(),
});

export const pointSlopePropsSchema = strokedSchema.extend({
  type: z.literal("pointSlope"),
  point: vector2Schema,
  slope: z.number(),
});

export const segmentPropsSchema = strokedSchema.extend({
  type: z.literal("segment"),
  point1: vector2Schema,
  point2: vector2Schema,
});

export const ellipsePropsSchema = filledSchema.extend({
  type: z.literal("ellipse"),
  center: vector2Schema,
  radius: vector2Schema,
  angle: z.number().optional(),
});

export const circlePropsSchema = filledSchema.extend({
  type: z.literal("circle"),
  center: vector2Schema,
  radius: z.number(),
});

export const polygonPropsSchema = filledSchema.extend({
  type: z.literal("polygon"),
  points: z.array(vector2Schema),
});

export const pointPropsSchema = z.object({
  type: z.literal("point"),
  x: z.number(),
  y: z.number(),
  color: z.string().optional(),
  opacity: z.number().optional(),
});

export const vectorPropsSchema = strokedSchema.extend({
  type: z.literal("vector"),
  tail: vector2Schema.optional(),
  tip: vector2Schema,
});

export const cardinalDirectionSchema = z.union([
  z.literal("n"),
  z.literal("ne"),
  z.literal("e"),
  z.literal("se"),
  z.literal("s"),
  z.literal("sw"),
  z.literal("w"),
  z.literal("nw"),
]);

export const textPropsSchema = z.object({
  type: z.literal("text"),
  x: z.number(),
  y: z.number(),
  attach: cardinalDirectionSchema,
  size: z.number(),
  color: z.string(),
  text: z.string(),
});

const constraintFunction1Schema = z
  .function()
  .args(vector2Schema)
  .returns(vector2Schema);

export const movablePointPropsSchema = z.object({
  type: z.literal("movablePoint"),
  point: vector2Schema,
  onMove: z.function().args(vector2Schema).returns(z.void()),
  constrain: z.function().args(vector2Schema).returns(vector2Schema),
  color: z.string().optional(),
});

export const constraintFunctionSchema = z
  .function()
  .args(vector2Schema)
  .returns(vector2Schema);

export const useMovablePointArgumentsSchema = z.object({
  type: z.literal("movablePoint"),
  color: z.string().optional(),
  constrain: z
    .union([
      z.literal("horizontal"),
      z.literal("vertical"),
      constraintFunctionSchema,
    ])
    .optional(),
});

export const useMovablePointSchema = z.object({
  x: z.number(),
  y: z.number(),
  point: vector2Schema,
  setPoint: z.function().args(vector2Schema).returns(z.void()),
});

export const stopwatchArgumentsSchema = z.object({
  type: z.literal("stopwatch"),
  startTime: z.number().optional(),
  endTime: z.number().optional(),
});

export const stopwatchSchema = z.object({
  time: z.number(),
  start: z.function().args().returns(z.void()),
  stop: z.function().args().returns(z.void()),
  setTime: z.function().args(z.number()).returns(z.void()),
});

export const paneContextSchema = z.object({
  type: z.literal("paneContext")
})

export const transformContextSchema = z.object({
  type: z.literal("transformContext")
})

// TODO: IMPLEMENT THIS
// export const transformPropsSchema = z.literal(React.PropsWithChildren);

const paneVisualizerPropsSchema = z.object({
  precision: z.number().optional(),
});

export const elementSchema = z
  .union([
    cartesianCoordinatesPropsSchema,
    parametricPropsSchema,
    vectorFieldPropsSchema,
    ofXPropsSchema,
    ofYPropsSchema,
    throughPointsPropsSchema,
    pointAnglePropsSchema,
    pointSlopePropsSchema,
    segmentPropsSchema,
    ellipsePropsSchema,
    circlePropsSchema,
    polygonPropsSchema,
    pointPropsSchema,
    vectorPropsSchema,
    textPropsSchema,
    movablePointPropsSchema
  ])

export const resourceSchema = z.union([
  useMovablePointArgumentsSchema,
  stopwatchArgumentsSchema,
  paneContextSchema,
  transformContextSchema
]).and(z.object({ name: z.string() }))

export const pageSchema = z.object({
  resources: z.array(resourceSchema),
  elements: z.array(elementSchema)
})

export const appletSchema = z.array(pageSchema);

// TODO: IMPLEMENT THIS
const transformWidgetPropsSchema = z.object({
  children: z.array(elementSchema),
});
